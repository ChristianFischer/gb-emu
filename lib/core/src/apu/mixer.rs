/*
 * Copyright (C) 2022-2023 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use crate::apu::channel::Channel;
use crate::apu::generators::SoundGenerator;
use crate::apu::registers::ApuRegisters;
use crate::utils::get_bit;

/// The mixer takes the values generated by each channel
/// and mixes them into left and right output channels
pub struct Mixer {
    channels_in:  [InputChannel; 4],

    volume_left:  u8,
    volume_right: u8,
}


/// Stores data of each input channel.
#[derive(Default, Copy, Clone)]
struct InputChannel {
    sample: i16,
    pan_left: bool,
    pan_right: bool,
}


impl Mixer {
    pub fn new() -> Self {
        Self {
            channels_in: [InputChannel::default(); 4],
            volume_left:  0,
            volume_right: 0,
        }
    }


    /// Updates the mixer config from the APU registers
    pub fn update_config(&mut self, apu_registers: &ApuRegisters) {
        for i in 0..4u8 {
            self.channels_in[i as usize].pan_left  = get_bit(apu_registers.nr51, i + 4);
            self.channels_in[i as usize].pan_right = get_bit(apu_registers.nr51, i + 0);
        }

        self.volume_left  = ((apu_registers.nr50 >> 4) & 0x07) + 1;
        self.volume_right = ((apu_registers.nr50 >> 0) & 0x07) + 1;
    }


    /// Takes and stores the data from the given audio channel.
    pub fn put<G : SoundGenerator>(&mut self, channel: &Channel<G>, registers: &ApuRegisters) {
        let sample = channel.get_sample(registers);

        self.channels_in[channel.get_channel_ordinal() as usize].sample = sample;
    }


    /// Mix input values into left and right output values.
    pub fn mix(&self) -> (i16, i16) {
        let mut left  = 0;
        let mut right = 0;

        for channel in &self.channels_in {
            if channel.pan_left {
                left += channel.sample;
            }

            if channel.pan_right {
                right += channel.sample;
            }
        }

        (left, right)
    }
}


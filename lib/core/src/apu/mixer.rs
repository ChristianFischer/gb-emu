/*
 * Copyright (C) 2022-2024 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use crate::apu::apu::ApuState;
use crate::apu::channels::channel::Channel;
use crate::apu::channels::generator::SoundGenerator;
use crate::apu::sample::{Sample, SampleResult, StereoSample};
use crate::utils::{as_bit_flag, change_bit, get_bit};

/// The mixer takes the values generated by each channel
/// and mixes them into left and right output channels
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mixer {
    channels_in:  [InputChannel; 4],

    vin_left:  bool,
    vin_right: bool,

    volume_left:  u8,
    volume_right: u8,
}


/// Stores data of each input channel.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
struct InputChannel {
    sample:     SampleResult<Sample>,
    pan_left:   bool,
    pan_right:  bool,
}


impl Mixer {
    pub fn new() -> Self {
        Self {
            channels_in:  [InputChannel::default(); 4],
            vin_left:     false,
            vin_right:    false,
            volume_left:  0,
            volume_right: 0,
        }
    }


    /// Write data into NR50.
    pub fn write_nr50(&mut self, value: u8) {
        self.volume_left  = ((value >> 4) & 0x07) + 1;
        self.volume_right = ((value >> 0) & 0x07) + 1;
        self.vin_left     = get_bit(value, 7);
        self.vin_right    = get_bit(value, 3);
    }


    /// Read from NR50.
    pub fn read_nr50(&self) -> u8 {
            0x00
        |   ((self.volume_left.wrapping_sub(1)  & 0x07) << 4)
        |   ((self.volume_right.wrapping_sub(1) & 0x07) << 0)
        |   as_bit_flag(self.vin_left,  7)
        |   as_bit_flag(self.vin_right, 3)
    }


    /// Write data into NR51.
    pub fn write_nr51(&mut self, value: u8) {
        for i in 0..4u8 {
            self.channels_in[i as usize].pan_left  = get_bit(value, i + 4);
            self.channels_in[i as usize].pan_right = get_bit(value, i + 0);
        }
    }


    /// Read from NR51.
    pub fn read_nr51(&self) -> u8 {
        let mut value = 0x00;

        for i in 0..4u8 {
            value = change_bit(value, i + 4, self.channels_in[i as usize].pan_left);
            value = change_bit(value, i + 0, self.channels_in[i as usize].pan_right);
        }

        value
    }


    /// Called when the APU was reset by turning it off.
    pub fn reset(&mut self) {
        for channel in &mut self.channels_in {
            channel.pan_left  = false;
            channel.pan_right = false;
        }

        self.volume_left  = 1;
        self.volume_right = 1;
        self.vin_left     = false;
        self.vin_right    = false;
    }


    /// Takes and stores the data from the given audio channel.
    pub fn put<G : SoundGenerator, const L:u8, const S:u8, const E:u8>(&mut self, channel: &Channel<G, L, S, E>, apu_state: &ApuState) {
        let sample = channel.get_sample(apu_state);

        self.channels_in[channel.get_channel_ordinal() as usize].sample = sample;
    }


    /// Mix input values into left and right output values.
    pub fn mix(&self) -> SampleResult<StereoSample> {
        let mut sample    = StereoSample::default();
        let mut is_silent = true;

        for channel in &self.channels_in {
            match channel.sample {
                // when the channel did produce an audio sample, it's value
                // will be added to the value of the current sampling result
                SampleResult::Audio(channel_sample) => {
                    if channel.pan_left {
                        sample.left += channel_sample / 4.0;
                    }

                    if channel.pan_right {
                        sample.right += channel_sample / 4.0;
                    }

                    is_silent = false;
                }

                SampleResult::Silence => { }
            }
        }

        // return audio data if we got audio data from at least one channel
        if is_silent {
            SampleResult::Silence
        }
        else {
            SampleResult::Audio(sample)
        }
    }
}

impl Default for InputChannel {
    fn default() -> Self {
        Self {
            sample:     SampleResult::Silence,
            pan_left:   true,
            pan_right:  true,
        }
    }
}

/*
 * Copyright (C) 2022-2023 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use crate::apu::channel::{Channel, ChannelType};
use crate::apu::generators::noise::NoiseGenerator;
use crate::apu::generators::pulse::{PulseGenerator, PulseSweepGenerator};
use crate::apu::generators::wave::WaveGenerator;
use crate::apu::mixer::Mixer;
use crate::apu::output_buffer::OutputBuffer;
use crate::gameboy::Clock;
use crate::memory::{MEMORY_LOCATION_APU_NR14, MEMORY_LOCATION_APU_NR24, MEMORY_LOCATION_APU_NR34, MEMORY_LOCATION_APU_NR44, MEMORY_LOCATION_APU_NR52, MemoryReadWriteHandle};
use crate::utils::get_bit;


pub const APU_UPDATE_PERIOD : Clock = 8_192;


/// Represents the GameBoys Audio Processing Unit.
/// The APU contains various components
/// * 4 Channels with each their distinct sound generator to create sound waves.
/// * A frame sequencer to periodically trigger subcomponents of each sound generator.
/// * A mixer to mix the sound waves generated by each channel into left and right
/// output channels.
pub struct Apu {
    mem: MemoryReadWriteHandle,

    apu_on: bool,

    /// The number of cycles which have been passed since the last update
    /// on each channel.
    channels_clock: Clock,

    /// Frame Sequencer clock
    fs_clock: Clock,

    /// Frame Sequencer step
    fs_step: u8,

    ch1: Channel<PulseSweepGenerator>,
    ch2: Channel<PulseGenerator>,
    ch3: Channel<WaveGenerator>,
    ch4: Channel<NoiseGenerator>,

    /// The mixer used to mix the signals of each input channel into stereo output channels
    mixer: Mixer,

    /// The buffer to receive the generated audio signal.
    output_buffer: OutputBuffer,
}


impl Apu {
    /// Creates a new APU object.
    pub fn new(mem: MemoryReadWriteHandle) -> Self {
        Self {
            mem,

            apu_on: true,

            channels_clock: 0,

            fs_clock: 0,
            fs_step: 0,

            ch1: Channel::new(ChannelType::Ch1Pulse1, PulseSweepGenerator::new()),
            ch2: Channel::new(ChannelType::Ch2Pulse2, PulseGenerator::new()),
            ch3: Channel::new(ChannelType::Ch3Wave,   WaveGenerator::new()),
            ch4: Channel::new(ChannelType::Ch4Noise,  NoiseGenerator::new()),

            mixer: Mixer::new(),

            output_buffer: OutputBuffer::new(),
        }
    }


    /// Updates the APUs internal components with the time passed.
    pub fn update(&mut self, cycles: Clock) {
        if let Some(value) = self.mem.take_changed_io_register(MEMORY_LOCATION_APU_NR52) {
            let enabled = get_bit(value, 7);

            if self.apu_on && !enabled {
                self.reset();
            }

            self.apu_on = enabled;
        }

        if self.apu_on {
            self.channels_clock += cycles;

            self.check_trigger_events();
            self.update_frame_sequencer(cycles);
        }
    }


    /// Checks for each channel whether it was triggered by it's control register
    fn check_trigger_events(&mut self) {
        macro_rules! check_trigger_event {
            ($channel_control_register:expr, $channel:expr) => {
                // Checks whether the channel was triggered by writing bit 7 into it's control register
                if let Some(value) = self.mem.take_changed_io_register($channel_control_register) {
                    let trigger = get_bit(value, 7);

                    if trigger {
                        $channel.fire_trigger_event(&(self.mem.get_io_registers().apu));
                    }
                }
            }
        }

        check_trigger_event!(MEMORY_LOCATION_APU_NR14, self.ch1);
        check_trigger_event!(MEMORY_LOCATION_APU_NR24, self.ch2);
        check_trigger_event!(MEMORY_LOCATION_APU_NR34, self.ch3);
        check_trigger_event!(MEMORY_LOCATION_APU_NR44, self.ch4);
    }


    /// Updates the frame sequencer with the time passed.
    /// This will periodically trigger some sound generator subcomponents.
    fn update_frame_sequencer(&mut self, cycles: Clock) {
        self.fs_clock = self.fs_clock.wrapping_add(cycles);

        while self.fs_clock >= APU_UPDATE_PERIOD {
            self.fs_clock -= APU_UPDATE_PERIOD;
            self.next_frame_sequencer_step();
        }
    }


    /// Process the next step of the frame sequencer to trigger sound generator subcomponents.
    fn next_frame_sequencer_step(&mut self) {
        self.fs_step = self.fs_step.wrapping_add(1);

        // before internal components of any sound generator may be changed,
        // generate all remaining audio data with the currently configured values.
        self.generate_audio();

        let apu_registers = &(self.mem.get_io_registers().apu);

        // 256Hz -> Sound length
        if (self.fs_step & 0b0001) == 0 {
            self.ch1.tick_sound_length(apu_registers);
            self.ch2.tick_sound_length(apu_registers);
            self.ch3.tick_sound_length(apu_registers);
            self.ch4.tick_sound_length(apu_registers);
        }

        // 128Hz -> CH1 freq sweep
        if (self.fs_step & 0b0011) == 0 {
            self.ch1.tick_freq_sweep(apu_registers);
            self.ch2.tick_freq_sweep(apu_registers);
            self.ch3.tick_freq_sweep(apu_registers);
            self.ch4.tick_freq_sweep(apu_registers);
        }

        // 64Hz -> Envelope sweep
        if (self.fs_step & 0b0111) == 0 {
            self.ch1.tick_envelope_sweep(apu_registers);
            self.ch2.tick_envelope_sweep(apu_registers);
            self.ch3.tick_envelope_sweep(apu_registers);
            self.ch4.tick_envelope_sweep(apu_registers);
        }
    }


    /// Updates the input channels by consuming the pending time in `channels_clock`
    /// and generates audio data up to the current moment.
    fn generate_audio(&mut self) {
        let apu_registers = &(self.mem.get_io_registers().apu);
        let cycles_per_sample = self.output_buffer.get_cycles_per_sample();

        self.mixer.update_config(apu_registers);

        while self.channels_clock >= cycles_per_sample {
            self.channels_clock -= cycles_per_sample;

            self.ch1.update(apu_registers, cycles_per_sample);
            self.ch2.update(apu_registers, cycles_per_sample);
            self.ch3.update(apu_registers, cycles_per_sample);
            self.ch4.update(apu_registers, cycles_per_sample);

            self.mixer.put(&self.ch1, apu_registers);
            self.mixer.put(&self.ch2, apu_registers);
            self.mixer.put(&self.ch3, apu_registers);
            self.mixer.put(&self.ch4, apu_registers);

            // mix all input values into left & right channels
            // according to their mixer settings
            let (sample_left, sample_right) = self.mixer.mix();

            self.output_buffer.push(sample_left, sample_right);
        }

        // todo: channels_clock contains a remainder, which should be applied to channels as well
    }


    /// Reset the APUs internal data.
    fn reset(&mut self) {

    }


    pub fn take_samples(&mut self) -> Vec<i16> {
        self.output_buffer.take_samples()
    }
}

/*
 * Copyright (C) 2022-2023 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use crate::apu::channels::channel::{Channel, ChannelType};
use crate::apu::channels::channel::features::*;
use crate::apu::channels::noise::NoiseGenerator;
use crate::apu::channels::pulse::PulseGenerator;
use crate::apu::channels::wave::WaveGenerator;
use crate::apu::mixer::Mixer;
use crate::apu::output_buffer::OutputBuffer;
use crate::gameboy::Clock;
use crate::memory::*;
use crate::utils::get_bit;


pub const APU_UPDATE_PERIOD : Clock = 8_192;


type Channel1 = Channel<
    PulseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_ENABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;

type Channel2 = Channel<
    PulseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;

type Channel3 = Channel<
    WaveGenerator,
    FEATURE_LENGTH_TIMER_8_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_DISABLED,
>;

type Channel4 = Channel<
    NoiseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;


/// Represents the GameBoys Audio Processing Unit.
/// The APU contains various components
/// * 4 Channels with each their distinct sound generator to create sound waves.
/// * A frame sequencer to periodically trigger subcomponents of each sound generator.
/// * A mixer to mix the sound waves generated by each channel into left and right
/// output channels.
pub struct Apu {
    mem: MemoryReadWriteHandle,

    apu_on: bool,

    /// The number of cycles which have been passed since the last update
    /// on each channel.
    channels_clock: Clock,

    /// Frame Sequencer clock
    fs_clock: Clock,

    /// Frame Sequencer step
    fs_step: u8,

    ch1: Channel1,
    ch2: Channel2,
    ch3: Channel3,
    ch4: Channel4,

    /// The mixer used to mix the signals of each input channel into stereo output channels
    mixer: Mixer,

    /// The buffer to receive the generated audio signal.
    output_buffer: OutputBuffer,
}


impl Apu {
    /// Creates a new APU object.
    pub fn new(mem: MemoryReadWriteHandle) -> Self {
        Self {
            mem,

            apu_on: true,

            channels_clock: 0,

            fs_clock: 0,
            fs_step: 0,

            ch1: Channel::new(ChannelType::Ch1Pulse1),
            ch2: Channel::new(ChannelType::Ch2Pulse2),
            ch3: Channel::new(ChannelType::Ch3Wave),
            ch4: Channel::new(ChannelType::Ch4Noise),

            mixer: Mixer::new(),

            output_buffer: OutputBuffer::new(),
        }
    }


    /// Updates the APUs internal components with the time passed.
    pub fn update(&mut self, cycles: Clock) {
        if let Some(value) = self.mem.take_changed_io_register(MEMORY_LOCATION_APU_NR52) {
            let enabled = get_bit(value, 7);

            if self.apu_on && !enabled {
                self.reset();
            }

            self.apu_on = enabled;
        }

        if self.apu_on {
            self.channels_clock += cycles;

            self.check_register_changes();
            self.update_frame_sequencer(cycles);
        }
    }


    /// Checks for each channel whether one of it's registers were changed
    /// and additionally if it's trigger bit was set to trigger the channel on.
    fn check_register_changes(&mut self) {
        macro_rules! check_register_change {
            ($register:expr, $channel:expr) => {
                if let Some(value) = self.mem.take_changed_io_register($register) {
                    let apu_registers = &(self.mem.get_io_registers().apu);
                    let number = ($register - MEMORY_LOCATION_APU_NR10) % 5;
                    $channel.fire_register_changed(number, apu_registers);

                    // additionally, for the control register, check for the trigger event as well,
                    // so it does not need to be done in the channels themself
                    if number == 4 {
                        let trigger = get_bit(value, 7);

                        if trigger {
                            $channel.fire_trigger_event();
                        }
                    }
                }
            }
        }

        check_register_change!(MEMORY_LOCATION_APU_NR10, self.ch1);
        check_register_change!(MEMORY_LOCATION_APU_NR11, self.ch1);
        check_register_change!(MEMORY_LOCATION_APU_NR12, self.ch1);
        check_register_change!(MEMORY_LOCATION_APU_NR13, self.ch1);
        check_register_change!(MEMORY_LOCATION_APU_NR14, self.ch1);

        check_register_change!(MEMORY_LOCATION_APU_NR21, self.ch2);
        check_register_change!(MEMORY_LOCATION_APU_NR22, self.ch2);
        check_register_change!(MEMORY_LOCATION_APU_NR23, self.ch2);
        check_register_change!(MEMORY_LOCATION_APU_NR24, self.ch2);

        check_register_change!(MEMORY_LOCATION_APU_NR30, self.ch3);
        check_register_change!(MEMORY_LOCATION_APU_NR31, self.ch3);
        check_register_change!(MEMORY_LOCATION_APU_NR32, self.ch3);
        check_register_change!(MEMORY_LOCATION_APU_NR33, self.ch3);
        check_register_change!(MEMORY_LOCATION_APU_NR34, self.ch3);

        check_register_change!(MEMORY_LOCATION_APU_NR41, self.ch4);
        check_register_change!(MEMORY_LOCATION_APU_NR42, self.ch4);
        check_register_change!(MEMORY_LOCATION_APU_NR43, self.ch4);
        check_register_change!(MEMORY_LOCATION_APU_NR44, self.ch4);
    }


    /// Updates the frame sequencer with the time passed.
    /// This will periodically trigger some sound generator subcomponents.
    fn update_frame_sequencer(&mut self, cycles: Clock) {
        self.fs_clock = self.fs_clock.wrapping_add(cycles);

        while self.fs_clock >= APU_UPDATE_PERIOD {
            self.fs_clock -= APU_UPDATE_PERIOD;
            self.next_frame_sequencer_step();
        }
    }


    /// Process the next step of the frame sequencer to trigger sound generator subcomponents.
    fn next_frame_sequencer_step(&mut self) {
        self.fs_step = self.fs_step.wrapping_add(1);

        // before internal components of any sound generator may be changed,
        // generate all remaining audio data with the currently configured values.
        self.generate_audio();

        // 256Hz -> Sound length
        if (self.fs_step & 0b0001) == 0 {
            self.ch1.tick_length_timer();
            self.ch2.tick_length_timer();
            self.ch3.tick_length_timer();
            self.ch4.tick_length_timer();
        }

        // 128Hz -> CH1 freq sweep
        if (self.fs_step & 0b0011) == 0 {
            self.ch1.tick_freq_sweep();
            self.ch2.tick_freq_sweep();
            self.ch3.tick_freq_sweep();
            self.ch4.tick_freq_sweep();
        }

        // 64Hz -> Envelope sweep
        if (self.fs_step & 0b0111) == 0 {
            self.ch1.tick_envelope_sweep();
            self.ch2.tick_envelope_sweep();
            self.ch3.tick_envelope_sweep();
            self.ch4.tick_envelope_sweep();
        }
    }


    /// Updates the input channels by consuming the pending time in `channels_clock`
    /// and generates audio data up to the current moment.
    fn generate_audio(&mut self) {
        let apu_registers = &(self.mem.get_io_registers().apu);
        let cycles_per_sample = self.output_buffer.get_cycles_per_sample();

        self.mixer.update_config(apu_registers);

        while self.channels_clock >= cycles_per_sample {
            self.channels_clock -= cycles_per_sample;

            self.ch1.update(cycles_per_sample);
            self.ch2.update(cycles_per_sample);
            self.ch3.update(cycles_per_sample);
            self.ch4.update(cycles_per_sample);

            self.mixer.put(&self.ch1, apu_registers);
            self.mixer.put(&self.ch2, apu_registers);
            self.mixer.put(&self.ch3, apu_registers);
            self.mixer.put(&self.ch4, apu_registers);

            // mix all input values into left & right channels
            // according to their mixer settings
            let (sample_left, sample_right) = self.mixer.mix();

            self.output_buffer.push(sample_left, sample_right);
        }

        // todo: channels_clock contains a remainder, which should be applied to channels as well
    }


    /// Reset the APUs internal data.
    fn reset(&mut self) {

    }


    pub fn take_samples(&mut self) -> Vec<i16> {
        self.output_buffer.take_samples()
    }
}

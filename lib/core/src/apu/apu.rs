/*
 * Copyright (C) 2022-2023 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use crate::apu::channels::channel::{Channel, ChannelType};
use crate::apu::channels::channel::features::*;
use crate::apu::channels::noise::NoiseGenerator;
use crate::apu::channels::pulse::PulseGenerator;
use crate::apu::channels::wave::WaveGenerator;
use crate::apu::mixer::Mixer;
use crate::apu::output_buffer::OutputBuffer;
use crate::gameboy::Clock;
use crate::mmu::locations::*;
use crate::mmu::memory_bus::MemoryBusConnection;
use crate::utils::{as_bit_flag, get_bit};


pub const APU_UPDATE_PERIOD : Clock = 8_192;

const NR52_NON_READABLE_BITS : u8   = 0b_0111_0000;


type Channel1 = Channel<
    PulseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_ENABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;

type Channel2 = Channel<
    PulseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;

type Channel3 = Channel<
    WaveGenerator,
    FEATURE_LENGTH_TIMER_8_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_DISABLED,
>;

type Channel4 = Channel<
    NoiseGenerator,
    FEATURE_LENGTH_TIMER_6_BIT,
    FEATURE_FREQUENCY_SWEEP_DISABLED,
    FEATURE_VOLUME_ENVELOPE_ENABLED,
>;


/// An alias to a 16 byte array containing the wave RAM for channel 3.
#[derive(Default)]
pub struct WaveRam(pub [u8; 16]);


/// The current state of the APU.
/// This includes the information, if the APU is enabled or not
/// and information about the current frame sequencer state.
pub struct ApuState {
    pub apu_on: bool,

    /// Frame Sequencer clock
    pub fs_clock: Clock,

    /// Frame Sequencer step
    pub fs_step: u8,

    /// Wave pattern RAM, which will be used
    /// for playback by channel 3.
    pub wave_ram: WaveRam,
}


/// Represents the GameBoys Audio Processing Unit.
/// The APU contains various components
/// * 4 Channels with each their distinct sound generator to create sound waves.
/// * A frame sequencer to periodically trigger subcomponents of each sound generator.
/// * A mixer to mix the sound waves generated by each channel into left and right
/// output channels.
pub struct Apu {
    /// The number of cycles which have been passed since the last update
    /// on each channel.
    channels_clock: Clock,

    /// Information about the APUs current state.
    state: ApuState,

    ch1: Channel1,
    ch2: Channel2,
    ch3: Channel3,
    ch4: Channel4,

    /// The mixer used to mix the signals of each input channel into stereo output channels
    mixer: Mixer,

    /// The buffer to receive the generated audio signal.
    output_buffer: OutputBuffer,
}


impl Apu {
    /// Creates a new APU object.
    pub fn new() -> Self {
        Self {
            channels_clock: 0,

            state: ApuState {
                apu_on:     true,
                fs_clock:   0,
                fs_step:    0,
                wave_ram:   WaveRam::default()
            },

            ch1: Channel::new(ChannelType::Ch1Pulse1),
            ch2: Channel::new(ChannelType::Ch2Pulse2),
            ch3: Channel::new(ChannelType::Ch3Wave),
            ch4: Channel::new(ChannelType::Ch4Noise),

            mixer: Mixer::new(),

            output_buffer: OutputBuffer::new(),
        }
    }


    /// Updates the APUs internal components with the time passed.
    pub fn update(&mut self, cycles: Clock) {
        if self.state.apu_on {
            self.channels_clock += cycles;

            self.update_frame_sequencer(cycles);
        }
    }


    /// Updates the frame sequencer with the time passed.
    /// This will periodically trigger some sound generator subcomponents.
    fn update_frame_sequencer(&mut self, cycles: Clock) {
        self.state.fs_clock = self.state.fs_clock.wrapping_add(cycles);

        while self.state.fs_clock >= APU_UPDATE_PERIOD {
            self.state.fs_clock -= APU_UPDATE_PERIOD;
            self.next_frame_sequencer_step();
        }
    }


    /// Process the next step of the frame sequencer to trigger sound generator subcomponents.
    fn next_frame_sequencer_step(&mut self) {
        self.state.fs_step = self.state.fs_step.wrapping_add(1);

        // before internal components of any sound generator may be changed,
        // generate all remaining audio data with the currently configured values.
        self.generate_audio();

        // 256Hz -> Sound length
        if (self.state.fs_step & 0b0001) == 0 {
            self.ch1.tick_length_timer();
            self.ch2.tick_length_timer();
            self.ch3.tick_length_timer();
            self.ch4.tick_length_timer();
        }

        // 128Hz -> CH1 freq sweep
        if (self.state.fs_step & 0b0011) == 0 {
            self.ch1.tick_freq_sweep();
            self.ch2.tick_freq_sweep();
            self.ch3.tick_freq_sweep();
            self.ch4.tick_freq_sweep();
        }

        // 64Hz -> Envelope sweep
        if (self.state.fs_step & 0b0111) == 0 {
            self.ch1.tick_envelope_sweep();
            self.ch2.tick_envelope_sweep();
            self.ch3.tick_envelope_sweep();
            self.ch4.tick_envelope_sweep();
        }
    }


    /// Updates the input channels by consuming the pending time in `channels_clock`
    /// and generates audio data up to the current moment.
    fn generate_audio(&mut self) {
        let cycles_per_sample = self.output_buffer.get_cycles_per_sample();

        while self.channels_clock >= cycles_per_sample {
            self.channels_clock -= cycles_per_sample;

            self.ch1.update(cycles_per_sample);
            self.ch2.update(cycles_per_sample);
            self.ch3.update(cycles_per_sample);
            self.ch4.update(cycles_per_sample);

            self.mixer.put(&self.ch1, &self.state);
            self.mixer.put(&self.ch2, &self.state);
            self.mixer.put(&self.ch3, &self.state);
            self.mixer.put(&self.ch4, &self.state);

            // mix all input values into left & right channels
            // according to their mixer settings
            let (sample_left, sample_right) = self.mixer.mix();

            self.output_buffer.push(sample_left, sample_right);
        }

        // todo: channels_clock contains a remainder, which should be applied to channels as well
    }


    /// Reset the APUs internal data.
    fn reset(&mut self) {
        self.mixer.reset();
        self.ch1.reset();
        self.ch2.reset();
        self.ch3.reset();
        self.ch4.reset();
    }


    pub fn take_samples(&mut self) -> Vec<i16> {
        self.output_buffer.take_samples()
    }
}


impl MemoryBusConnection for Apu {
    fn on_read(&self, address: u16) -> u8 {
        match address {
            MEMORY_LOCATION_APU_NR10 ..= MEMORY_LOCATION_APU_NR14 => {
                let number = address - MEMORY_LOCATION_APU_NR10;
                self.ch1.on_read_register(number)
            }

            MEMORY_LOCATION_APU_NR21 ..= MEMORY_LOCATION_APU_NR24 => {
                let number = address - MEMORY_LOCATION_APU_NR20;
                self.ch2.on_read_register(number)
            }

            MEMORY_LOCATION_APU_NR30 ..= MEMORY_LOCATION_APU_NR34 => {
                let number = address - MEMORY_LOCATION_APU_NR30;
                self.ch3.on_read_register(number)
            }

            MEMORY_LOCATION_APU_NR41 ..= MEMORY_LOCATION_APU_NR44 => {
                let number = address - MEMORY_LOCATION_APU_NR40;
                self.ch4.on_read_register(number)
            }

            MEMORY_LOCATION_APU_NR50 => {
                self.mixer.read_nr50()
            },

            MEMORY_LOCATION_APU_NR51 => {
                self.mixer.read_nr51()
            },

            MEMORY_LOCATION_APU_NR52 => {
                if self.state.apu_on {
                        NR52_NON_READABLE_BITS
                    |   as_bit_flag(self.state.apu_on, 7)
                    |   as_bit_flag(self.ch1.is_channel_enabled(), 0)
                    |   as_bit_flag(self.ch2.is_channel_enabled(), 1)
                    |   as_bit_flag(self.ch3.is_channel_enabled(), 2)
                    |   as_bit_flag(self.ch4.is_channel_enabled(), 3)
                }
                else {
                    NR52_NON_READABLE_BITS
                }
            },

            // Wave RAM
            0xff30 ..= 0xff3f => {
                let index = (address - 0xff30) as usize;
                self.state.wave_ram.0[index]
            }

            _ => 0xff
        }
    }


    fn on_write(&mut self, address: u16, value: u8) {
        match address {
            MEMORY_LOCATION_APU_NR10 ..= MEMORY_LOCATION_APU_NR14 => {
                if self.state.apu_on {
                    let number = address - MEMORY_LOCATION_APU_NR10;
                    self.ch1.on_write_register(number, value, &self.state);
                }
            }

            MEMORY_LOCATION_APU_NR21 ..= MEMORY_LOCATION_APU_NR24 => {
                if self.state.apu_on {
                    let number = address - MEMORY_LOCATION_APU_NR20;
                    self.ch2.on_write_register(number, value, &self.state);
                }
            }

            MEMORY_LOCATION_APU_NR30 ..= MEMORY_LOCATION_APU_NR34 => {
                if self.state.apu_on {
                    let number = address - MEMORY_LOCATION_APU_NR30;
                    self.ch3.on_write_register(number, value, &self.state);
                }
            }

            MEMORY_LOCATION_APU_NR41 ..= MEMORY_LOCATION_APU_NR44 => {
                if self.state.apu_on {
                    let number = address - MEMORY_LOCATION_APU_NR40;
                    self.ch4.on_write_register(number, value, &self.state);
                }
            }

            MEMORY_LOCATION_APU_NR50 => {
                if self.state.apu_on {
                    self.mixer.write_nr50(value);
                }
            },

            MEMORY_LOCATION_APU_NR51 => {
                if self.state.apu_on {
                    self.mixer.write_nr51(value);
                }
            },

            MEMORY_LOCATION_APU_NR52 => {
                let enabled = get_bit(value, 7);

                if self.state.apu_on && !enabled {
                    self.reset();
                }

                self.state.apu_on = enabled;
            },

            // Wave RAM
            0xff30 ..= 0xff3f => {
                let index = (address - 0xff30) as usize;
                self.state.wave_ram.0[index] = value;
            }

            _ => { }
        };
    }
}
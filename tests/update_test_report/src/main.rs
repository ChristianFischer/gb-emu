/*
 * Copyright (C) 2022-2023 by Christian Fischer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

use std::cell::RefCell;
use std::path::PathBuf;
use std::rc::Rc;
use std::sync::Arc;
use futures::{future, StreamExt};
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
use tests_shared::config::{SOURCE_URL, TESTRUNNER_PATH, TESTRUNNER_SUBDIR_ROM_FILES};
use tests_shared::download::download_test_roms;
use tests_shared::io_utils::{update_file, Workspace};
use tests_shared::test_suites::{ALL_TEST_SUITES, TestSuite};
use crate::report_generator::TestReportGenerator;


mod report_generator;


const TEST_ROM_SUMMARY_HEADER : &str = /* language=markdown */ r#"
## Test ROM Results

The emulator is tested against several well known test suites to check if the emulator's
functionality is as close as possible to the original hardware. Since even the original
GameBoy devices had some bugs or unexpected behaviour, it requires a lot of effort and
continuous testing.

This document is generated by the `update-test-report` tool which runs each test rom on the
emulator for each valid device model.
To update this file, call `run --package update-test-report --release --bin update-test-report`.


|                                                    |   ✔️   |   ❌   |   ⚠️   |   ☠️   |
|----------------------------------------------------|-------:|-------:|-------:|-------:|
"#;

const TEST_ROM_SUMMARY_FOOTER : &str = /* language=markdown */ r#"
## Symbols

|    | Meaning                                      |
|:--:|:---------------------------------------------|
| ✔️ | Test passed                                  |
| ❌  | Test ran, but did not receive a success code |
| ⚠️ | The emulator failed to run for some reason   |
| ☠️ | The emulator panicked while running the test |
"#;


/// Collection of all objects required to collect and process tests.
struct ProcessTestSuiteEntry {
    pub test_suite:     &'static TestSuite,
    pub generator:      TestReportGenerator,
    pub bar:            ProgressBar,
}


#[tokio::main()]
pub async fn main() {
    let workspace = Arc::new(
        Workspace::for_root_path(PathBuf::from(
            format!("{}/{}", TESTRUNNER_PATH, TESTRUNNER_SUBDIR_ROM_FILES)
        )
    ));

    // download test ROM archive, if the target directory does not exist yet
    if !workspace.get_root_path().is_dir() {
        download_test_roms(workspace.get_root_path(), &SOURCE_URL);
    }

    // progress bar manager
    let bar_manager = MultiProgress::new();
    bar_manager.set_draw_target(indicatif::ProgressDrawTarget::stdout());

    // progress bar style
    let progress_bar_template_str = "[{elapsed_precise}] [{bar:40.cyan/blue}] {pos:>7}/{len:7} {msg}";
    let bar_style =
        ProgressStyle::default_bar()
        .progress_chars("━━┄")
    ;

    // create an entry for each test suite and set them up
    let process_test_suites_stream =
        tokio_stream::iter(ALL_TEST_SUITES.iter())

        // setup each test suite and collect all test ROM files
        .map(|test_suite| {
            let generator_rc = Rc::new(RefCell::new(
                TestReportGenerator::new(&workspace)
            ));

            // visit all test ROMS and generate test cases for each of them
            test_suite.start(&workspace, generator_rc.clone());

            // take the generator out of the Rc, which is not required anymore
            // so we're able to send the generator across thread boundaries
            let generator = Rc::try_unwrap(generator_rc)
                .unwrap_or_else(|_| panic!("Failed to unwrap Rc"))
                .into_inner()
            ;

            // Progress bar
            let num_tests = generator.get_test_case_count();
            let bar = bar_manager.add(ProgressBar::new(num_tests as u64));
            bar.set_style(bar_style
                .clone()
                .template(&format!(
                    "{:10} {}",
                    test_suite.name,
                    progress_bar_template_str)
                )
                .unwrap_or_else(|_| bar_style.clone())
            );

            bar.set_position(0);

            // pack together into an entry
            ProcessTestSuiteEntry {
                test_suite,
                generator,
                bar,
            }
        })

        // run each test suite in a separate thread
        .map(|mut entry| {
            tokio::spawn(async move {
                // this will actually run the tests and generate the test report output
                entry.generator.run_all_tests(entry.bar.clone()).await;

                // finish the progress bar
                entry.bar.finish_with_message("done");

                // forward the entry
                entry
            })
        })

        .collect::<Vec<_>>()
        .await
    ;

    // await all futures
    let test_suites = future::join_all(process_test_suites_stream.into_iter()).await
        .into_iter()
        .map(|entry| entry.unwrap())
        .collect::<Vec<_>>()
    ;

    // try to update the target files of each test suite
    for entry in &test_suites {
        let file_path = PathBuf::from(&format!(
            "doc/test_report_{}.md",
            entry.test_suite.name
        ));

        // get the generated file content
        let file_content = entry.generator.generate_file_content(entry.test_suite.title);

        update_file(&file_path, &file_content);
    }

    // generate the summary table
    {
        let test_summary_table = test_suites
            .iter()
            .map(|entry| {
                let test_suite  = entry.test_suite;
                let stats       = entry.generator.collect_stats();
                let total_tests = entry.generator.get_test_case_count();
                let to_percent  = 100.0 / (total_tests as f32);

                format!(
                    "| {:50} | {:5.1}% | {:5.1}% | {:5.1}% | {:5.1}% |\n",
                    format!("[{}](test_report_{}.md)", test_suite.title, test_suite.name),
                    (stats.success  as f32) * to_percent,
                    (stats.failed   as f32) * to_percent,
                    (stats.errors   as f32) * to_percent,
                    (stats.panicked as f32) * to_percent
                )
            })
            .collect::<String>()
        ;

        // update summary file
        update_file(
            &PathBuf::from("doc/test_report.md"),
            &format!(
                "{}{}{}",
                TEST_ROM_SUMMARY_HEADER,
                test_summary_table,
                TEST_ROM_SUMMARY_FOOTER,
            )
        );
    }
}
